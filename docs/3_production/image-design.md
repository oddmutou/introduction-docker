---
title: イメージの仕組みと設計
description: Dockerイメージの仕組みと、それを意識した設計を紹介します。
---

DockerイメージはDockerfileによって作成されるスナップショットでした。  
コンテナはDockerイメージを元に起動が行うことが可能です。

この章ではそのイメージとコンテナについて仕組みについて学んで頂き、より良い設計の一助になれば幸いです


## 「1コンテナ = 1プロセス」
コンテナは1つのプロセスを実行するための技術です。  

基本的に「1コンテナ = 1プロセス」で設計をし、もし複数のプロセスを動かすことになってしまった場合はイメージを分ける目安でしょう。  
ただ、リアルワールドでは全てのケースで一概に「1コンテナ = 1プロセス」で完結しないことがあります。  
その場合は「1つのコンテナにつき1つの責務」を目安にすることがが良いでしょう。  

!!! note "The Twelve-Factor App"
    Heroku社が提唱するモダンなサービスを実現するための12の方法論です。  
    コンテナの設計に迷ってしまった場合、まずはThe Twelve-Factor Appを参考に設計開発を行うことがオススメです。

    [The Twelve-Factor App （日本語訳）](https://12factor.net/ja/)

## ファイルシステム
イメージはRead-Onlyで、その上にRead-Write可能なコンテナレイヤーが立ち上がるのがイメージとコンテナの仕組みです。  
コンテナ上でなんらかの変更が発生した場合、コンテナレイヤーにのみ変更が行われイメージに変更は反映されません。

Dockerの現行のファイルシステムはOverlayFS2が採用されています。  
過去のファイルシステムでは複数の中間レイヤーから生成されるイメージの上にコンテナが立ち上がる形でした。  

現行のファイルシステムではコンテナ起動時に上位レイヤー（コンテナ）と下位レイヤー（イメージ）の2つになり、中間レイヤーを意識する必要がなくなりました。  
しかし、開発時には中間レイヤーをキャッシュとして持ってくれるため、中間レイヤーを意識することには変わりません。

![overlayfs2](imgs/overlayfs2.png)

!!! note "過去のファイルシステム"
    Dockerは過去Unison FileSystem(とAUFS)というファイルシステムが使用されていました。  
    このファイルシステムではOverlayFS2とは異なり、中間レイヤーを強く意識する必要がありました。

    ### Container
    Read-Onlyイメージの上に、Read-Writeを行うコンテナレイヤーが生成されることは変わりません。  
    ![container](imgs/container.png)

    ### Image
    しかし、 `RUN` や `COPY` などで中間レイヤーを増やすたびに、このファイルシステムの仕様上コンテナから **中間レイヤー1つずつにアクセスが走り** 、オーバーヘッドが発生してしまうことが問題でした。  
    ![Unison FileSystem](imgs/unison-fs.png)

    現行のファイルシステムであるOverlayFS2では実行時に上位レイヤー（コンテナ）と、下位レイヤー（イメージ）の2つに分けられ、下位レイヤーは中間レイヤーを意識する必要がなくなりました。

## まとめ
* イメージは「1コンテナ = 1プロセス」の責務になるよう設計します。
* イメージはRead-Onlyで、その上にRead-Writeを行うためのコンテナ（レイヤー）が立ち上がります。
* 実行時に中間レイヤーのオーバーヘッドを意識する必要は無くなったが、キャッシュとして意識する必要は変わりません。
